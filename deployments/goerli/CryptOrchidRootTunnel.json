{
  "address": "0x4d3991906E23fA3E7b7297569C3bE3c3B4F3fFeB",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_checkpointManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_fxRoot",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_CryptOrchidERC721",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CryptOrchidERC721",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SEND_MESSAGE_EVENT_SIG",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "checkpointManager",
      "outputs": [
        {
          "internalType": "contract ICheckpointManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fxChildTunnel",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fxRoot",
      "outputs": [
        {
          "internalType": "contract IFxStateSender",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "latestData",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "processedExits",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "inputData",
          "type": "bytes"
        }
      ],
      "name": "receiveMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "sendMessageToChild",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_fxChildTunnel",
          "type": "address"
        }
      ],
      "name": "setFxChildTunnel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xda36401ab6eb431651ebb879d17216daa70fbf46b1beadbf04e648ae305c8c8a",
  "receipt": {
    "to": null,
    "from": "0x0090720FeD7Fed66eD658118b7B3BB0189D3A495",
    "contractAddress": "0x4d3991906E23fA3E7b7297569C3bE3c3B4F3fFeB",
    "transactionIndex": 32,
    "gasUsed": "1775858",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x068c0757f02bdd3229ef0b475e929adbbc1d0f6745d44b95009c9ed3b9e0eb63",
    "transactionHash": "0xda36401ab6eb431651ebb879d17216daa70fbf46b1beadbf04e648ae305c8c8a",
    "logs": [],
    "blockNumber": 4865987,
    "cumulativeGasUsed": "7993442",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2890bA17EfE978480615e330ecB65333b880928e",
    "0x3d1d3E34f7fB6D26245E6640E1c50710eFFf15bA",
    "0xb3EA7Cbb180d834c279B06873b6A971CCe701468"
  ],
  "solcInputHash": "044a1064ec6b174d77e4f6f8cf396848",
  "metadata": "{\"compiler\":{\"version\":\"0.6.6+commit.6c089d02\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkpointManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fxRoot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CryptOrchidERC721\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CryptOrchidERC721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"sendMessageToChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChildTunnel\",\"type\":\"address\"}],\"name\":\"setFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"receiveMessage(bytes)\":{\"details\":\"This function verifies if the transaction actually happened on child chain\",\"params\":{\"inputData\":\"RLP encoded data of the reference tx containing following list of fields 0 - headerNumber - Checkpoint header block number containing the reference tx 1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root 2 - blockNumber - Block number containing the reference tx on child chain 3 - blockTime - Reference tx block time 4 - txRoot - Transactions root of block 5 - receiptRoot - Receipts root of block 6 - receipt - Receipt of the reference transaction 7 - receiptProof - Merkle proof of the reference receipt 8 - branchMask - 32 bits denoting the path of receipt in merkle tree 9 - receiptLogIndex - Log Index to read from the receipt\"}}},\"title\":\"CryptOrchidRootTunnel\"},\"userdoc\":{\"methods\":{\"receiveMessage(bytes)\":{\"notice\":\"receive message from  L2 to L1, validated by proof\"}}}},\"settings\":{\"compilationTarget\":{\"contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol\":\"CryptOrchidRootTunnel\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6 <0.9.0;\\n\\nimport {FxBaseRootTunnel} from \\\"../Libraries/tunnel/FxBaseRootTunnel.sol\\\";\\n\\ninterface CryptOrchidParent {\\n    enum Stage {Unsold, Seed, Flower, Dead}\\n\\n    function getTokenMetadata(uint256 tokenId)\\n        external\\n        view\\n        returns (\\n            string memory,\\n            uint256,\\n            uint256,\\n            Stage\\n        );\\n}\\n\\n/**\\n * @title CryptOrchidRootTunnel\\n */\\ncontract CryptOrchidRootTunnel is FxBaseRootTunnel {\\n    bytes public latestData;\\n    address public CryptOrchidERC721;\\n\\n    constructor(\\n        address _checkpointManager,\\n        address _fxRoot,\\n        address _CryptOrchidERC721\\n    ) public FxBaseRootTunnel(_checkpointManager, _fxRoot) {\\n        CryptOrchidERC721 = _CryptOrchidERC721;\\n    }\\n\\n    function _processMessageFromChild(bytes memory data) internal override {\\n        latestData = data;\\n        uint256 tokenId = abi.decode(data, (uint256));\\n        sendMessageToChild(tokenId);\\n    }\\n\\n    function sendMessageToChild(uint256 tokenId) public {\\n        // TODO:\\n        // 1. check owner?\\n\\n        (string memory species, uint256 plantedAt, uint256 waterLevel, ) = CryptOrchidParent(CryptOrchidERC721)\\n            .getTokenMetadata(tokenId);\\n\\n        bytes memory message = abi.encode(species, plantedAt, waterLevel, tokenId);\\n\\n        _sendMessageToChild(message);\\n    }\\n}\\n\",\"keccak256\":\"0x8ecf7285367936fa40be85e563922839297116a49e7b5699a51b6912851dd422\"},\"contracts/Libraries/tunnel/FxBaseRootTunnel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6 <0.9.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\nimport {MerklePatriciaProof} from \\\"./MerklePatriciaProof.sol\\\";\\nimport {Merkle} from \\\"./Merkle.sol\\\";\\n\\ninterface IFxStateSender {\\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\\n}\\n\\ncontract ICheckpointManager {\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n\\n    /**\\n     * @notice mapping of checkpoint header numbers to block details\\n     * @dev These checkpoints are submited by plasma contracts\\n     */\\n    mapping(uint256 => HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n    using Merkle for bytes32;\\n\\n    // keccak256(MessageSent(bytes))\\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n    // state sender contract\\n    IFxStateSender public fxRoot;\\n    // root chain manager\\n    ICheckpointManager public checkpointManager;\\n    // child tunnel contract which receives and sends messages\\n    address public fxChildTunnel;\\n\\n    // storage to avoid duplicate exits\\n    mapping(bytes32 => bool) public processedExits;\\n\\n    constructor(address _checkpointManager, address _fxRoot) internal {\\n        checkpointManager = ICheckpointManager(_checkpointManager);\\n        fxRoot = IFxStateSender(_fxRoot);\\n    }\\n\\n    // set fxChildTunnel if not set already\\n    function setFxChildTunnel(address _fxChildTunnel) public {\\n        require(fxChildTunnel == address(0x0), \\\"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\\\");\\n        fxChildTunnel = _fxChildTunnel;\\n    }\\n\\n    /**\\n     * @notice Send bytes message to Child Tunnel\\n     * @param message bytes message that will be sent to Child Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToChild(bytes memory message) internal {\\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\\n    }\\n\\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\\n        RLPReader.RLPItem[] memory inputDataRLPList = inputData.toRlpItem().toList();\\n\\n        // checking if exit has already been processed\\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n        bytes32 exitHash = keccak256(\\n            abi.encodePacked(\\n                inputDataRLPList[2].toUint(), // blockNumber\\n                // first 2 nibbles are dropped while generating nibble array\\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n                // so converting to nibble array and then hashing it\\n                MerklePatriciaProof._getNibbleArray(inputDataRLPList[8].toBytes()), // branchMask\\n                inputDataRLPList[9].toUint() // receiptLogIndex\\n            )\\n        );\\n        require(processedExits[exitHash] == false, \\\"FxRootTunnel: EXIT_ALREADY_PROCESSED\\\");\\n        processedExits[exitHash] = true;\\n\\n        RLPReader.RLPItem[] memory receiptRLPList = inputDataRLPList[6].toBytes().toRlpItem().toList();\\n        RLPReader.RLPItem memory logRLP = receiptRLPList[3].toList()[inputDataRLPList[9].toUint()]; // receiptLogIndex\\n\\n        RLPReader.RLPItem[] memory logRLPList = logRLP.toList();\\n\\n        // check child tunnel\\n        require(fxChildTunnel == RLPReader.toAddress(logRLPList[0]), \\\"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\\\");\\n\\n        // verify receipt inclusion\\n        require(\\n            MerklePatriciaProof.verify(\\n                inputDataRLPList[6].toBytes(), // receipt\\n                inputDataRLPList[8].toBytes(), // branchMask\\n                inputDataRLPList[7].toBytes(), // receiptProof\\n                bytes32(inputDataRLPList[5].toUint()) // receiptRoot\\n            ),\\n            \\\"FxRootTunnel: INVALID_RECEIPT_PROOF\\\"\\n        );\\n\\n        // verify checkpoint inclusion\\n        _checkBlockMembershipInCheckpoint(\\n            inputDataRLPList[2].toUint(), // blockNumber\\n            inputDataRLPList[3].toUint(), // blockTime\\n            bytes32(inputDataRLPList[4].toUint()), // txRoot\\n            bytes32(inputDataRLPList[5].toUint()), // receiptRoot\\n            inputDataRLPList[0].toUint(), // headerNumber\\n            inputDataRLPList[1].toBytes() // blockProof\\n        );\\n\\n        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics\\n\\n        require(\\n            bytes32(logTopicRLPList[0].toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n            \\\"FxRootTunnel: INVALID_SIGNATURE\\\"\\n        );\\n\\n        // received message data\\n        bytes memory receivedData = logRLPList[2].toBytes();\\n        bytes memory message = abi.decode(receivedData, (bytes)); // event decodes params again, so decoding bytes to get message\\n        return message;\\n    }\\n\\n    function _checkBlockMembershipInCheckpoint(\\n        uint256 blockNumber,\\n        uint256 blockTime,\\n        bytes32 txRoot,\\n        bytes32 receiptRoot,\\n        uint256 headerNumber,\\n        bytes memory blockProof\\n    ) private view returns (uint256) {\\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\\n\\n        require(\\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\\n                blockNumber - startBlock,\\n                headerRoot,\\n                blockProof\\n            ),\\n            \\\"FxRootTunnel: INVALID_HEADER\\\"\\n        );\\n        return createdAt;\\n    }\\n\\n    /**\\n     * @notice receive message from  L2 to L1, validated by proof\\n     * @dev This function verifies if the transaction actually happened on child chain\\n     *\\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n     *  2 - blockNumber - Block number containing the reference tx on child chain\\n     *  3 - blockTime - Reference tx block time\\n     *  4 - txRoot - Transactions root of block\\n     *  5 - receiptRoot - Receipts root of block\\n     *  6 - receipt - Receipt of the reference transaction\\n     *  7 - receiptProof - Merkle proof of the reference receipt\\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n     *  9 - receiptLogIndex - Log Index to read from the receipt\\n     */\\n    function receiveMessage(bytes memory inputData) public virtual {\\n        bytes memory message = _validateAndExtractMessage(inputData);\\n        _processMessageFromChild(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Child Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param message bytes message that was sent from Child Tunnel\\n     */\\n    function _processMessageFromChild(bytes memory message) internal virtual;\\n}\\n\",\"keccak256\":\"0xf886005b901e40c04e6ab7902efbc65314855897f57d240629886c06873c757f\"},\"contracts/Libraries/tunnel/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6 <0.9.0;\\n\\nlibrary Merkle {\\n    function checkMembership(\\n        bytes32 leaf,\\n        uint256 index,\\n        bytes32 rootHash,\\n        bytes memory proof\\n    ) internal pure returns (bool) {\\n        require(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n        uint256 proofHeight = proof.length / 32;\\n        // Proof of size n means, height of the tree is n+1.\\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\\n        require(index < 2**proofHeight, \\\"Leaf index is too big\\\");\\n\\n        bytes32 proofElement;\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            assembly {\\n                proofElement := mload(add(proof, i))\\n            }\\n\\n            if (index % 2 == 0) {\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n\\n            index = index / 2;\\n        }\\n        return computedHash == rootHash;\\n    }\\n}\\n\",\"keccak256\":\"0x75e1779f276a19fcb26a9865a7c5405b7c35928dc24bdc03d9fd0c55f10650bf\"},\"contracts/Libraries/tunnel/MerklePatriciaProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6 <0.9.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n    /*\\n     * @dev Verifies a merkle patricia proof.\\n     * @param value The terminating value in the trie.\\n     * @param encodedPath The path in the trie leading to value.\\n     * @param rlpParentNodes The rlp encoded stack of nodes.\\n     * @param root The root hash of the trie.\\n     * @return The boolean validity of the proof.\\n     */\\n    function verify(\\n        bytes memory value,\\n        bytes memory encodedPath,\\n        bytes memory rlpParentNodes,\\n        bytes32 root\\n    ) internal pure returns (bool) {\\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n        bytes memory currentNode;\\n        RLPReader.RLPItem[] memory currentNodeList;\\n\\n        bytes32 nodeKey = root;\\n        uint256 pathPtr = 0;\\n\\n        bytes memory path = _getNibbleArray(encodedPath);\\n        if (path.length == 0) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < parentNodes.length; i++) {\\n            if (pathPtr > path.length) {\\n                return false;\\n            }\\n\\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n            if (nodeKey != keccak256(currentNode)) {\\n                return false;\\n            }\\n            currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n            if (currentNodeList.length == 17) {\\n                if (pathPtr == path.length) {\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                uint8 nextPathNibble = uint8(path[pathPtr]);\\n                if (nextPathNibble > 16) {\\n                    return false;\\n                }\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\\n                pathPtr += 1;\\n            } else if (currentNodeList.length == 2) {\\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\\n                if (pathPtr + traversed == path.length) {\\n                    //leaf node\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                //extension node\\n                if (traversed == 0) {\\n                    return false;\\n                }\\n\\n                pathPtr += traversed;\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    function _nibblesToTraverse(\\n        bytes memory encodedPartialPath,\\n        bytes memory path,\\n        uint256 pathPtr\\n    ) private pure returns (uint256) {\\n        uint256 len = 0;\\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n        // and slicedPath have elements that are each one hex character (1 nibble)\\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n        bytes memory slicedPath = new bytes(partialPath.length);\\n\\n        // pathPtr counts nibbles in path\\n        // partialPath.length is a number of nibbles\\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n            bytes1 pathNibble = path[i];\\n            slicedPath[i - pathPtr] = pathNibble;\\n        }\\n\\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\\n            len = partialPath.length;\\n        } else {\\n            len = 0;\\n        }\\n        return len;\\n    }\\n\\n    // bytes b must be hp encoded\\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\\n        bytes memory nibbles = \\\"\\\";\\n        if (b.length > 0) {\\n            uint8 offset;\\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n            if (hpNibble == 1 || hpNibble == 3) {\\n                nibbles = new bytes(b.length * 2 - 1);\\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n                nibbles[0] = oddNibble;\\n                offset = 1;\\n            } else {\\n                nibbles = new bytes(b.length * 2 - 2);\\n                offset = 0;\\n            }\\n\\n            for (uint256 i = offset; i < nibbles.length; i++) {\\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n            }\\n        }\\n        return nibbles;\\n    }\\n\\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\\n    }\\n}\\n\",\"keccak256\":\"0x385acb922054e3bf199668e5f3ce36f597c6e7ead1d3a2cc0fd6a6406e1136a3\"},\"contracts/Libraries/tunnel/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        require(item.length > 0, \\\"RLPReader: INVALID_BYTES_LENGTH\\\");\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded list in bytes\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item), \\\"RLPReader: ITEM_NOT_LIST\\\");\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n        uint256 listLength = _itemLength(item.memPtr);\\n        require(listLength == item.len, \\\"RLPReader: LIST_DECODED_LENGTH_MISMATCH\\\");\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        require(!isList(item), \\\"RLPReader: DECODING_LIST_AS_ADDRESS\\\");\\n        // 1 byte for the length prefix\\n        require(item.len == 21, \\\"RLPReader: INVALID_ADDRESS_LENGTH\\\");\\n\\n        return address(toUint(item));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(!isList(item), \\\"RLPReader: DECODING_LIST_AS_UINT\\\");\\n        require(item.len <= 33, \\\"RLPReader: INVALID_UINT_LENGTH\\\");\\n\\n        uint256 itemLength = _itemLength(item.memPtr);\\n        require(itemLength == item.len, \\\"RLPReader: UINT_DECODED_LENGTH_MISMATCH\\\");\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset;\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        uint256 itemLength = _itemLength(item.memPtr);\\n        require(itemLength == item.len, \\\"RLPReader: UINT_STRICT_DECODED_LENGTH_MISMATCH\\\");\\n        // one byte prefix\\n        require(item.len == 33, \\\"RLPReader: INVALID_UINT_STRICT_LENGTH\\\");\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        uint256 listLength = _itemLength(item.memPtr);\\n        require(listLength == item.len, \\\"RLPReader: BYTES_DECODED_LENGTH_MISMATCH\\\");\\n        uint256 offset = _payloadOffset(item.memPtr);\\n\\n        uint256 len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        // add `isList` check if `item` is expected to be passsed without a check from calling function\\n        // require(isList(item), \\\"RLPReader: NUM_ITEMS_NOT_LIST\\\");\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            require(currPtr <= endPtr, \\\"RLPReader: NUM_ITEMS_DECODED_LENGTH_MISMATCH\\\");\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) return 0;\\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\\n        else if (byte0 < LIST_SHORT_START)\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7fe606b4996782cff2d0409365bc591a5b8bfd6957ff3659ecd08ff2076e1570\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051611e77380380611e778339818101604052606081101561003357600080fd5b5080516020820151604090920151600180546001600160a01b039384166001600160a01b0319918216179091556000805494841694821694909417909355600580549290911691909216179055611de88061008f6000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063aea4e49e11610066578063aea4e49e146101ae578063c0857ba0146101d4578063de9b771f146101dc578063f2c0dd39146101e4578063f953cec7146101ec5761009e565b80630c903de5146100a35780630e387de6146100c2578063142bc2ae146100dc578063607f2d4214610159578063972c49281461018a575b600080fd5b6100c0600480360360208110156100b957600080fd5b5035610292565b005b6100ca610497565b60408051918252519081900360200190f35b6100e46104bb565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561011e578181015183820152602001610106565b50505050905090810190601f16801561014b5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101766004803603602081101561016f57600080fd5b5035610549565b604080519115158252519081900360200190f35b61019261055e565b604080516001600160a01b039092168252519081900360200190f35b6100c0600480360360208110156101c457600080fd5b50356001600160a01b031661056d565b6101926105d7565b6101926105e6565b6101926105f5565b6100c06004803603602081101561020257600080fd5b81019060208101813564010000000081111561021d57600080fd5b82018360208201111561022f57600080fd5b8035906020019184600183028401116401000000008311171561025157600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610604945050505050565b60055460408051636031680160e01b815260048101849052905160609260009283926001600160a01b03909216916360316801916024808201928692909190829003018186803b1580156102e557600080fd5b505afa1580156102f9573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052608081101561032257600080fd5b810190808051604051939291908464010000000082111561034257600080fd5b90830190602082018581111561035757600080fd5b825164010000000081118282018810171561037157600080fd5b82525081516020918201929091019080838360005b8381101561039e578181015183820152602001610386565b50505050905090810190601f1680156103cb5780820380516001836020036101000a031916815260200191505b50604081815260208381015193820151918301849052606080840183905260808085018d9052828501908152885160a08601528851989b50949950919750909589955088945087938b939092839260c0909201919088019080838360005b83811015610441578181015183820152602001610429565b50505050905090810190601f16801561046e5780820380516001836020036101000a031916815260200191505b509550505050505060405160208183030381529060405290506104908161061e565b5050505050565b7f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03681565b6004805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156105415780601f1061051657610100808354040283529160200191610541565b820191906000526020600020905b81548152906001019060200180831161052457829003601f168201915b505050505081565b60036020526000908152604090205460ff1681565b6002546001600160a01b031681565b6002546001600160a01b0316156105b55760405162461bcd60e51b815260040180806020018281038252602a815260200180611c09602a913960400191505060405180910390fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6001546001600160a01b031681565b6000546001600160a01b031681565b6005546001600160a01b031681565b606061060f826106f0565b905061061a81610b93565b5050565b600080546002546040805163b472047760e01b81526001600160a01b039283166004820181815260248301938452875160448401528751949095169563b472047795919488949293606401916020860191908190849084905b8381101561068f578181015183820152602001610677565b50505050905090810190601f1680156106bc5780820380516001836020036101000a031916815260200191505b509350505050600060405180830381600087803b1580156106dc57600080fd5b505af1158015610490573d6000803e3d6000fd5b6060806107046106ff84610bcb565b610c46565b905060006107258260028151811061071857fe5b6020026020010151610dc8565b61074a6107458460088151811061073857fe5b6020026020010151610f10565b610fda565b61075a8460098151811061071857fe5b6040516020018084815260200183805190602001908083835b602083106107925780518252601f199092019160209182019101610773565b51815160209384036101000a6000190180199092169116179052920193845250604080518085038152938201815283519382019390932060008181526003909252929020549194505060ff1615915061081e90505760405162461bcd60e51b8152600401808060200182810382526024815260200180611c566024913960400191505060405180910390fd5b6000818152600360205260409020805460ff19166001179055815160609061085a906106ff90610855908690600690811061073857fe5b610bcb565b9050610864611b2e565b6108818260038151811061087457fe5b6020026020010151610c46565b6108918560098151811061071857fe5b8151811061089b57fe5b6020026020010151905060606108b082610c46565b90506108cf816000815181106108c257fe5b602002602001015161114e565b6002546001600160a01b0390811691161461091b5760405162461bcd60e51b8152600401808060200182810382526025815260200180611d186025913960400191505060405180910390fd5b61096361092e8660068151811061073857fe5b61093e8760088151811061073857fe5b61094e8860078151811061073857fe5b61095e8960058151811061071857fe5b6111de565b61099e5760405162461bcd60e51b8152600401808060200182810382526023815260200180611c336023913960400191505060405180910390fd5b610a0c6109b18660028151811061071857fe5b6109c18760038151811061071857fe5b6109d18860048151811061071857fe5b60001b6109e48960058151811061071857fe5b60001b6109f78a60008151811061071857fe5b610a078b60018151811061073857fe5b611425565b506060610a1f8260018151811061087457fe5b90507f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03660001b610a558260008151811061071857fe5b14610aa7576040805162461bcd60e51b815260206004820152601f60248201527f4678526f6f7454756e6e656c3a20494e56414c49445f5349474e415455524500604482015290519081900360640190fd5b6060610ab98360028151811061073857fe5b90506060818060200190516020811015610ad257600080fd5b8101908080516040519392919084640100000000821115610af257600080fd5b908301906020820185811115610b0757600080fd5b8251640100000000811182820188101715610b2157600080fd5b82525081516020918201929091019080838360005b83811015610b4e578181015183820152602001610b36565b50505050905090810190601f168015610b7b5780820380516001836020036101000a031916815260200191505b5060405250919a50505050505050505050505b919050565b8051610ba6906004906020840190611b48565b506000818060200190516020811015610bbe57600080fd5b5051905061061a81610292565b610bd3611b2e565b6000825111610c29576040805162461bcd60e51b815260206004820152601f60248201527f524c505265616465723a20494e56414c49445f42595445535f4c454e47544800604482015290519081900360640190fd5b506040805180820190915281518152602082810190820152919050565b6060610c5182611597565b610ca2576040805162461bcd60e51b815260206004820152601860248201527f524c505265616465723a204954454d5f4e4f545f4c4953540000000000000000604482015290519081900360640190fd5b6000610cad836115c3565b905060608167ffffffffffffffff81118015610cc857600080fd5b50604051908082528060200260200182016040528015610d0257816020015b610cef611b2e565b815260200190600190039081610ce75790505b5090506000610d14856020015161164f565b85519091508114610d565760405162461bcd60e51b8152600401808060200182810382526027815260200180611cf16027913960400191505060405180910390fd5b6000610d6586602001516116e8565b60208701510190506000805b85811015610dbc57610d828361164f565b9150604051806040016040528083815260200184815250858281518110610da557fe5b602090810291909101015291810191600101610d71565b50929695505050505050565b6000610dd382611597565b15610e25576040805162461bcd60e51b815260206004820181905260248201527f524c505265616465723a204445434f44494e475f4c4953545f41535f55494e54604482015290519081900360640190fd5b815160211015610e7c576040805162461bcd60e51b815260206004820152601e60248201527f524c505265616465723a20494e56414c49445f55494e545f4c454e4754480000604482015290519081900360640190fd5b6000610e8b836020015161164f565b83519091508114610ecd5760405162461bcd60e51b8152600401808060200182810382526027815260200180611d6b6027913960400191505060405180910390fd5b6000610edc84602001516116e8565b84516020808701518301805193945091849003929190831015610f0657826020036101000a820491505b5095945050505050565b60606000610f21836020015161164f565b83519091508114610f635760405162461bcd60e51b8152600401808060200182810382526028815260200180611c7a6028913960400191505060405180910390fd5b6000610f7284602001516116e8565b845190915081900360608167ffffffffffffffff81118015610f9357600080fd5b506040519080825280601f01601f191660200182016040528015610fbe576020820181803683370190505b5090506000816020019050610f0684886020015101828561174b565b6040805160208101909152600081528151606091901561114857600080611002600086611796565b60f81c9050600181148061101957508060ff166003145b156110a857600185516002020367ffffffffffffffff8111801561103c57600080fd5b506040519080825280601f01601f191660200182016040528015611067576020820181803683370190505b5092506000611077600187611796565b9050808460008151811061108757fe5b60200101906001600160f81b031916908160001a90535060019250506110f9565b600285516002020367ffffffffffffffff811180156110c657600080fd5b506040519080825280601f01601f1916602001820160405280156110f1576020820181803683370190505b509250600091505b60ff82165b8351811015611144576111198360ff16820360020187611796565b84828151811061112557fe5b60200101906001600160f81b031916908160001a9053506001016110fe565b5050505b92915050565b600061115982611597565b156111955760405162461bcd60e51b8152600401808060200182810382526023815260200180611cce6023913960400191505060405180910390fd5b81516015146111d55760405162461bcd60e51b8152600401808060200182810382526021815260200180611d926021913960400191505060405180910390fd5b61114882610dc8565b60006111e8611b2e565b6111f184610bcb565b905060606111fe82610c46565b9050606080856000826112108b610fda565b905080516000141561122c57600097505050505050505061141d565b60005b86518110156114145781518311156112525760009850505050505050505061141d565b61126e87828151811061126157fe5b60200260200101516117f3565b95508580519060200120841461128f5760009850505050505050505061141d565b61129e87828151811061087457fe5b945084516011141561135b5781518314156112fa578c805190602001206112cb8660108151811061073857fe5b8051906020012014156112e95760019850505050505050505061141d565b60009850505050505050505061141d565b600082848151811061130857fe5b016020015160f81c9050601081111561132d576000995050505050505050505061141d565b61134c868260ff168151811061133f57fe5b602002602001015161185a565b9450506001929092019161140c565b8451600214156112e957600061138161137a8760008151811061073857fe5b84866118f9565b9050825181850114156113d7578d805190602001206113a68760018151811061073857fe5b8051906020012014156113c5576001995050505050505050505061141d565b6000995050505050505050505061141d565b806113ee576000995050505050505050505061141d565b80840193506114038660018151811061133f57fe5b945061140c9050565b60010161122f565b50505050505050505b949350505050565b600154604080516320a9cea560e11b81526004810185905290516000928392839283926001600160a01b0316916341539d4a9160248083019260a0929190829003018186803b15801561147757600080fd5b505afa15801561148b573d6000803e3d6000fd5b505050506040513d60a08110156114a157600080fd5b8101908080519060200190929190805190602001909291908051906020019092919080519060200190929190805190602001909291905050505093505092509250611539828b0384878d8d8d8d60405160200180858152602001848152602001838152602001828152602001945050505050604051602081830303815290604052805190602001206119d8909392919063ffffffff16565b61158a576040805162461bcd60e51b815260206004820152601c60248201527f4678526f6f7454756e6e656c3a20494e56414c49445f48454144455200000000604482015290519081900360640190fd5b9998505050505050505050565b6020810151805160009190821a9060c08210156115b957600092505050610b8e565b5060019392505050565b6000806000905060006115d984602001516116e8565b602085015185519181019250015b80821015611646576115f88261164f565b820191508082111561163b5760405162461bcd60e51b815260040180806020018281038252602c815260200180611ca2602c913960400191505060405180910390fd5b6001909201916115e7565b50909392505050565b80516000908190811a608081101561166a57600191506116e1565b60b881101561167f57607e19810191506116e1565b60c08110156116ac5760b78103600185019450806020036101000a855104600182018101935050506116e1565b60f88110156116c15760be19810191506116e1565b60f78103600185019450806020036101000a855104600182018101935050505b5092915050565b8051600090811a6080811015611702576000915050610b8e565b60b881108061171d575060c0811080159061171d575060f881105b1561172c576001915050610b8e565b60c08110156117405760b519019050610b8e565b60f519019050610b8e565b8061175557611791565b5b60208110611775578251825260209283019290910190601f1901611756565b8251825160208390036101000a60001901801990921691161782525b505050565b600060028306156117c75760108260028504815181106117b257fe5b016020015160f81c816117c157fe5b066117e9565b60108260028504815181106117d857fe5b016020015160f81c816117e757fe5b045b60f81b9392505050565b606080826000015167ffffffffffffffff8111801561181157600080fd5b506040519080825280601f01601f19166020018201604052801561183c576020820181803683370190505b50905060008160200190506116e1846020015182866000015161174b565b60008061186a836020015161164f565b835190915081146118ac5760405162461bcd60e51b815260040180806020018281038252602e815260200180611d3d602e913960400191505060405180910390fd5b82516021146118ec5760405162461bcd60e51b8152600401808060200182810382526025815260200180611be46025913960400191505060405180910390fd5b5050602001516001015190565b600080606061190786610fda565b90506060815167ffffffffffffffff8111801561192357600080fd5b506040519080825280601f01601f19166020018201604052801561194e576020820181803683370190505b509050845b825186018110156119a857600087828151811061196c57fe5b602001015160f81c60f81b905080838884038151811061198857fe5b60200101906001600160f81b031916908160001a90535050600101611953565b508080519060200120828051906020012014156119c857815192506119cd565b600092505b509095945050505050565b600060208251816119e557fe5b0615611a2f576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e0e4dedecc40d8cadccee8d60631b604482015290519081900360640190fd5b60006020835181611a3c57fe5b0490508060020a8510611a8e576040805162461bcd60e51b81526020600482015260156024820152744c65616620696e64657820697320746f6f2062696760581b604482015290519081900360640190fd5b60008660205b85518111611b205785810151925060028806611ae05781836040516020018083815260200182815260200192505050604051602081830303815290604052805190602001209150611b12565b828260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091505b600288049750602001611a94565b509094149695505050505050565b604051806040016040528060008152602001600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10611b8957805160ff1916838001178555611bb6565b82800160010185558215611bb6579182015b82811115611bb6578251825591602001919060010190611b9b565b50611bc2929150611bc6565b5090565b611be091905b80821115611bc25760008155600101611bcc565b9056fe524c505265616465723a20494e56414c49445f55494e545f5354524943545f4c454e475448467842617365526f6f7454756e6e656c3a204348494c445f54554e4e454c5f414c52454144595f5345544678526f6f7454756e6e656c3a20494e56414c49445f524543454950545f50524f4f464678526f6f7454756e6e656c3a20455849545f414c52454144595f50524f434553534544524c505265616465723a2042595445535f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a204e554d5f4954454d535f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a204445434f44494e475f4c4953545f41535f41444452455353524c505265616465723a204c4953545f4445434f4445445f4c454e4754485f4d49534d415443484678526f6f7454756e6e656c3a20494e56414c49445f46585f4348494c445f54554e4e454c524c505265616465723a2055494e545f5354524943545f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a2055494e545f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a20494e56414c49445f414444524553535f4c454e475448a2646970667358221220d29f7066321780c0e925442b2f117cc8c896858aed5cfe437686905db996047b64736f6c63430006060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c8063aea4e49e11610066578063aea4e49e146101ae578063c0857ba0146101d4578063de9b771f146101dc578063f2c0dd39146101e4578063f953cec7146101ec5761009e565b80630c903de5146100a35780630e387de6146100c2578063142bc2ae146100dc578063607f2d4214610159578063972c49281461018a575b600080fd5b6100c0600480360360208110156100b957600080fd5b5035610292565b005b6100ca610497565b60408051918252519081900360200190f35b6100e46104bb565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561011e578181015183820152602001610106565b50505050905090810190601f16801561014b5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101766004803603602081101561016f57600080fd5b5035610549565b604080519115158252519081900360200190f35b61019261055e565b604080516001600160a01b039092168252519081900360200190f35b6100c0600480360360208110156101c457600080fd5b50356001600160a01b031661056d565b6101926105d7565b6101926105e6565b6101926105f5565b6100c06004803603602081101561020257600080fd5b81019060208101813564010000000081111561021d57600080fd5b82018360208201111561022f57600080fd5b8035906020019184600183028401116401000000008311171561025157600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610604945050505050565b60055460408051636031680160e01b815260048101849052905160609260009283926001600160a01b03909216916360316801916024808201928692909190829003018186803b1580156102e557600080fd5b505afa1580156102f9573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052608081101561032257600080fd5b810190808051604051939291908464010000000082111561034257600080fd5b90830190602082018581111561035757600080fd5b825164010000000081118282018810171561037157600080fd5b82525081516020918201929091019080838360005b8381101561039e578181015183820152602001610386565b50505050905090810190601f1680156103cb5780820380516001836020036101000a031916815260200191505b50604081815260208381015193820151918301849052606080840183905260808085018d9052828501908152885160a08601528851989b50949950919750909589955088945087938b939092839260c0909201919088019080838360005b83811015610441578181015183820152602001610429565b50505050905090810190601f16801561046e5780820380516001836020036101000a031916815260200191505b509550505050505060405160208183030381529060405290506104908161061e565b5050505050565b7f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03681565b6004805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156105415780601f1061051657610100808354040283529160200191610541565b820191906000526020600020905b81548152906001019060200180831161052457829003601f168201915b505050505081565b60036020526000908152604090205460ff1681565b6002546001600160a01b031681565b6002546001600160a01b0316156105b55760405162461bcd60e51b815260040180806020018281038252602a815260200180611c09602a913960400191505060405180910390fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6001546001600160a01b031681565b6000546001600160a01b031681565b6005546001600160a01b031681565b606061060f826106f0565b905061061a81610b93565b5050565b600080546002546040805163b472047760e01b81526001600160a01b039283166004820181815260248301938452875160448401528751949095169563b472047795919488949293606401916020860191908190849084905b8381101561068f578181015183820152602001610677565b50505050905090810190601f1680156106bc5780820380516001836020036101000a031916815260200191505b509350505050600060405180830381600087803b1580156106dc57600080fd5b505af1158015610490573d6000803e3d6000fd5b6060806107046106ff84610bcb565b610c46565b905060006107258260028151811061071857fe5b6020026020010151610dc8565b61074a6107458460088151811061073857fe5b6020026020010151610f10565b610fda565b61075a8460098151811061071857fe5b6040516020018084815260200183805190602001908083835b602083106107925780518252601f199092019160209182019101610773565b51815160209384036101000a6000190180199092169116179052920193845250604080518085038152938201815283519382019390932060008181526003909252929020549194505060ff1615915061081e90505760405162461bcd60e51b8152600401808060200182810382526024815260200180611c566024913960400191505060405180910390fd5b6000818152600360205260409020805460ff19166001179055815160609061085a906106ff90610855908690600690811061073857fe5b610bcb565b9050610864611b2e565b6108818260038151811061087457fe5b6020026020010151610c46565b6108918560098151811061071857fe5b8151811061089b57fe5b6020026020010151905060606108b082610c46565b90506108cf816000815181106108c257fe5b602002602001015161114e565b6002546001600160a01b0390811691161461091b5760405162461bcd60e51b8152600401808060200182810382526025815260200180611d186025913960400191505060405180910390fd5b61096361092e8660068151811061073857fe5b61093e8760088151811061073857fe5b61094e8860078151811061073857fe5b61095e8960058151811061071857fe5b6111de565b61099e5760405162461bcd60e51b8152600401808060200182810382526023815260200180611c336023913960400191505060405180910390fd5b610a0c6109b18660028151811061071857fe5b6109c18760038151811061071857fe5b6109d18860048151811061071857fe5b60001b6109e48960058151811061071857fe5b60001b6109f78a60008151811061071857fe5b610a078b60018151811061073857fe5b611425565b506060610a1f8260018151811061087457fe5b90507f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03660001b610a558260008151811061071857fe5b14610aa7576040805162461bcd60e51b815260206004820152601f60248201527f4678526f6f7454756e6e656c3a20494e56414c49445f5349474e415455524500604482015290519081900360640190fd5b6060610ab98360028151811061073857fe5b90506060818060200190516020811015610ad257600080fd5b8101908080516040519392919084640100000000821115610af257600080fd5b908301906020820185811115610b0757600080fd5b8251640100000000811182820188101715610b2157600080fd5b82525081516020918201929091019080838360005b83811015610b4e578181015183820152602001610b36565b50505050905090810190601f168015610b7b5780820380516001836020036101000a031916815260200191505b5060405250919a50505050505050505050505b919050565b8051610ba6906004906020840190611b48565b506000818060200190516020811015610bbe57600080fd5b5051905061061a81610292565b610bd3611b2e565b6000825111610c29576040805162461bcd60e51b815260206004820152601f60248201527f524c505265616465723a20494e56414c49445f42595445535f4c454e47544800604482015290519081900360640190fd5b506040805180820190915281518152602082810190820152919050565b6060610c5182611597565b610ca2576040805162461bcd60e51b815260206004820152601860248201527f524c505265616465723a204954454d5f4e4f545f4c4953540000000000000000604482015290519081900360640190fd5b6000610cad836115c3565b905060608167ffffffffffffffff81118015610cc857600080fd5b50604051908082528060200260200182016040528015610d0257816020015b610cef611b2e565b815260200190600190039081610ce75790505b5090506000610d14856020015161164f565b85519091508114610d565760405162461bcd60e51b8152600401808060200182810382526027815260200180611cf16027913960400191505060405180910390fd5b6000610d6586602001516116e8565b60208701510190506000805b85811015610dbc57610d828361164f565b9150604051806040016040528083815260200184815250858281518110610da557fe5b602090810291909101015291810191600101610d71565b50929695505050505050565b6000610dd382611597565b15610e25576040805162461bcd60e51b815260206004820181905260248201527f524c505265616465723a204445434f44494e475f4c4953545f41535f55494e54604482015290519081900360640190fd5b815160211015610e7c576040805162461bcd60e51b815260206004820152601e60248201527f524c505265616465723a20494e56414c49445f55494e545f4c454e4754480000604482015290519081900360640190fd5b6000610e8b836020015161164f565b83519091508114610ecd5760405162461bcd60e51b8152600401808060200182810382526027815260200180611d6b6027913960400191505060405180910390fd5b6000610edc84602001516116e8565b84516020808701518301805193945091849003929190831015610f0657826020036101000a820491505b5095945050505050565b60606000610f21836020015161164f565b83519091508114610f635760405162461bcd60e51b8152600401808060200182810382526028815260200180611c7a6028913960400191505060405180910390fd5b6000610f7284602001516116e8565b845190915081900360608167ffffffffffffffff81118015610f9357600080fd5b506040519080825280601f01601f191660200182016040528015610fbe576020820181803683370190505b5090506000816020019050610f0684886020015101828561174b565b6040805160208101909152600081528151606091901561114857600080611002600086611796565b60f81c9050600181148061101957508060ff166003145b156110a857600185516002020367ffffffffffffffff8111801561103c57600080fd5b506040519080825280601f01601f191660200182016040528015611067576020820181803683370190505b5092506000611077600187611796565b9050808460008151811061108757fe5b60200101906001600160f81b031916908160001a90535060019250506110f9565b600285516002020367ffffffffffffffff811180156110c657600080fd5b506040519080825280601f01601f1916602001820160405280156110f1576020820181803683370190505b509250600091505b60ff82165b8351811015611144576111198360ff16820360020187611796565b84828151811061112557fe5b60200101906001600160f81b031916908160001a9053506001016110fe565b5050505b92915050565b600061115982611597565b156111955760405162461bcd60e51b8152600401808060200182810382526023815260200180611cce6023913960400191505060405180910390fd5b81516015146111d55760405162461bcd60e51b8152600401808060200182810382526021815260200180611d926021913960400191505060405180910390fd5b61114882610dc8565b60006111e8611b2e565b6111f184610bcb565b905060606111fe82610c46565b9050606080856000826112108b610fda565b905080516000141561122c57600097505050505050505061141d565b60005b86518110156114145781518311156112525760009850505050505050505061141d565b61126e87828151811061126157fe5b60200260200101516117f3565b95508580519060200120841461128f5760009850505050505050505061141d565b61129e87828151811061087457fe5b945084516011141561135b5781518314156112fa578c805190602001206112cb8660108151811061073857fe5b8051906020012014156112e95760019850505050505050505061141d565b60009850505050505050505061141d565b600082848151811061130857fe5b016020015160f81c9050601081111561132d576000995050505050505050505061141d565b61134c868260ff168151811061133f57fe5b602002602001015161185a565b9450506001929092019161140c565b8451600214156112e957600061138161137a8760008151811061073857fe5b84866118f9565b9050825181850114156113d7578d805190602001206113a68760018151811061073857fe5b8051906020012014156113c5576001995050505050505050505061141d565b6000995050505050505050505061141d565b806113ee576000995050505050505050505061141d565b80840193506114038660018151811061133f57fe5b945061140c9050565b60010161122f565b50505050505050505b949350505050565b600154604080516320a9cea560e11b81526004810185905290516000928392839283926001600160a01b0316916341539d4a9160248083019260a0929190829003018186803b15801561147757600080fd5b505afa15801561148b573d6000803e3d6000fd5b505050506040513d60a08110156114a157600080fd5b8101908080519060200190929190805190602001909291908051906020019092919080519060200190929190805190602001909291905050505093505092509250611539828b0384878d8d8d8d60405160200180858152602001848152602001838152602001828152602001945050505050604051602081830303815290604052805190602001206119d8909392919063ffffffff16565b61158a576040805162461bcd60e51b815260206004820152601c60248201527f4678526f6f7454756e6e656c3a20494e56414c49445f48454144455200000000604482015290519081900360640190fd5b9998505050505050505050565b6020810151805160009190821a9060c08210156115b957600092505050610b8e565b5060019392505050565b6000806000905060006115d984602001516116e8565b602085015185519181019250015b80821015611646576115f88261164f565b820191508082111561163b5760405162461bcd60e51b815260040180806020018281038252602c815260200180611ca2602c913960400191505060405180910390fd5b6001909201916115e7565b50909392505050565b80516000908190811a608081101561166a57600191506116e1565b60b881101561167f57607e19810191506116e1565b60c08110156116ac5760b78103600185019450806020036101000a855104600182018101935050506116e1565b60f88110156116c15760be19810191506116e1565b60f78103600185019450806020036101000a855104600182018101935050505b5092915050565b8051600090811a6080811015611702576000915050610b8e565b60b881108061171d575060c0811080159061171d575060f881105b1561172c576001915050610b8e565b60c08110156117405760b519019050610b8e565b60f519019050610b8e565b8061175557611791565b5b60208110611775578251825260209283019290910190601f1901611756565b8251825160208390036101000a60001901801990921691161782525b505050565b600060028306156117c75760108260028504815181106117b257fe5b016020015160f81c816117c157fe5b066117e9565b60108260028504815181106117d857fe5b016020015160f81c816117e757fe5b045b60f81b9392505050565b606080826000015167ffffffffffffffff8111801561181157600080fd5b506040519080825280601f01601f19166020018201604052801561183c576020820181803683370190505b50905060008160200190506116e1846020015182866000015161174b565b60008061186a836020015161164f565b835190915081146118ac5760405162461bcd60e51b815260040180806020018281038252602e815260200180611d3d602e913960400191505060405180910390fd5b82516021146118ec5760405162461bcd60e51b8152600401808060200182810382526025815260200180611be46025913960400191505060405180910390fd5b5050602001516001015190565b600080606061190786610fda565b90506060815167ffffffffffffffff8111801561192357600080fd5b506040519080825280601f01601f19166020018201604052801561194e576020820181803683370190505b509050845b825186018110156119a857600087828151811061196c57fe5b602001015160f81c60f81b905080838884038151811061198857fe5b60200101906001600160f81b031916908160001a90535050600101611953565b508080519060200120828051906020012014156119c857815192506119cd565b600092505b509095945050505050565b600060208251816119e557fe5b0615611a2f576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e0e4dedecc40d8cadccee8d60631b604482015290519081900360640190fd5b60006020835181611a3c57fe5b0490508060020a8510611a8e576040805162461bcd60e51b81526020600482015260156024820152744c65616620696e64657820697320746f6f2062696760581b604482015290519081900360640190fd5b60008660205b85518111611b205785810151925060028806611ae05781836040516020018083815260200182815260200192505050604051602081830303815290604052805190602001209150611b12565b828260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091505b600288049750602001611a94565b509094149695505050505050565b604051806040016040528060008152602001600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10611b8957805160ff1916838001178555611bb6565b82800160010185558215611bb6579182015b82811115611bb6578251825591602001919060010190611b9b565b50611bc2929150611bc6565b5090565b611be091905b80821115611bc25760008155600101611bcc565b9056fe524c505265616465723a20494e56414c49445f55494e545f5354524943545f4c454e475448467842617365526f6f7454756e6e656c3a204348494c445f54554e4e454c5f414c52454144595f5345544678526f6f7454756e6e656c3a20494e56414c49445f524543454950545f50524f4f464678526f6f7454756e6e656c3a20455849545f414c52454144595f50524f434553534544524c505265616465723a2042595445535f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a204e554d5f4954454d535f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a204445434f44494e475f4c4953545f41535f41444452455353524c505265616465723a204c4953545f4445434f4445445f4c454e4754485f4d49534d415443484678526f6f7454756e6e656c3a20494e56414c49445f46585f4348494c445f54554e4e454c524c505265616465723a2055494e545f5354524943545f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a2055494e545f4445434f4445445f4c454e4754485f4d49534d41544348524c505265616465723a20494e56414c49445f414444524553535f4c454e475448a2646970667358221220d29f7066321780c0e925442b2f117cc8c896858aed5cfe437686905db996047b64736f6c63430006060033",
  "devdoc": {
    "methods": {
      "receiveMessage(bytes)": {
        "details": "This function verifies if the transaction actually happened on child chain",
        "params": {
          "inputData": "RLP encoded data of the reference tx containing following list of fields 0 - headerNumber - Checkpoint header block number containing the reference tx 1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root 2 - blockNumber - Block number containing the reference tx on child chain 3 - blockTime - Reference tx block time 4 - txRoot - Transactions root of block 5 - receiptRoot - Receipts root of block 6 - receipt - Receipt of the reference transaction 7 - receiptProof - Merkle proof of the reference receipt 8 - branchMask - 32 bits denoting the path of receipt in merkle tree 9 - receiptLogIndex - Log Index to read from the receipt"
        }
      }
    },
    "title": "CryptOrchidRootTunnel"
  },
  "userdoc": {
    "methods": {
      "receiveMessage(bytes)": {
        "notice": "receive message from  L2 to L1, validated by proof"
      }
    }
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 152,
        "contract": "contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol:CryptOrchidRootTunnel",
        "label": "fxRoot",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IFxStateSender)122"
      },
      {
        "astId": 154,
        "contract": "contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol:CryptOrchidRootTunnel",
        "label": "checkpointManager",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ICheckpointManager)138"
      },
      {
        "astId": 156,
        "contract": "contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol:CryptOrchidRootTunnel",
        "label": "fxChildTunnel",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 160,
        "contract": "contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol:CryptOrchidRootTunnel",
        "label": "processedExits",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 27,
        "contract": "contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol:CryptOrchidRootTunnel",
        "label": "latestData",
        "offset": 0,
        "slot": "4",
        "type": "t_bytes_storage"
      },
      {
        "astId": 29,
        "contract": "contracts/CryptOrchidRootTunnel/CryptOrchidRootTunnel.sol:CryptOrchidRootTunnel",
        "label": "CryptOrchidERC721",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(ICheckpointManager)138": {
        "encoding": "inplace",
        "label": "contract ICheckpointManager",
        "numberOfBytes": "20"
      },
      "t_contract(IFxStateSender)122": {
        "encoding": "inplace",
        "label": "contract IFxStateSender",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}